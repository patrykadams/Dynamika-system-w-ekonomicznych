
```{r}
model <- function (t, state , parameters ) {
with (as.list (c( state , parameters ) ) , {
dx <- a * x + b * y
dy <- c * x - d * y
list (c( dx , dy ) )})
}
```



```{r}
library ( deSolve )
growth <- function (t, state , parameters ) {
with (as.list (c( state , parameters ) ) , {
dx <- r * x
list (c( dx ) )
})
}
# Warunki poczatkowe i parametry
state <- c( x = 1)
parameters <- c( r = 0.5)
times <- seq (0 , 10 , by = 0.1)
# Calkowanie numeryczne
out <- ode ( y = state , times = times , func = growth , parms =
, parameters )
head ( out )

```

```{r}
library ( ggplot2 )
out_df <- as.data.frame ( out )
ggplot( out_df , aes ( x = time , y = x ) ) +
geom_line ( color = " steelblue ", linewidth = 1) +
labs ( title = " Exponential Growth Model ",
x = " Time ", y = "x(t)") +
theme_minimal ()
```



```{r}
oscillator <- function (t, state , parameters ) {
with (as.list (c( state , parameters ) ) , {
dx <- y
dy <- -k * x
list (c( dx , dy ) )
})
}
state <- c( x = 1 , y = 0)
parameters <- c( k = 2)
times <- seq (0 , 20 , by = 0.05)
out <- ode ( y = state , times = times , func = oscillator , parms =
, parameters )
out_df <- as.data.frame ( out )
ggplot( out_df , aes ( x = time , y = x ) ) +
geom_line( color = " darkorange ", linewidth = 1) +
labs ( title = " Harmonic Oscillator : x(t)",
x = " Time ", y = "x(t)") +
theme_minimal ()

```



```{r}
ggplot ( out_df , aes ( x = x , y = y ) ) +
geom_path ( color = " darkred ", linewidth = 1) +
labs ( title = " Phase Portrait of the Harmonic Oscillator ",
x = "x(t)", y = "y(t)") +
theme_minimal ()

```

```{r}
# Load necessary libraries
library(deSolve)   # for ode
library(ggplot2)   # for plotting
library(dplyr)     # for data transformation

# Define the growth function
growth <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    dx <- r * x
    list(c(dx))
  })
}

# Define rates
rates <- c(0.2, 0.5, 1.0)

# Run the ODE for each rate and bind the results
results <- do.call(rbind, lapply(rates, function(r) {
  out <- ode(y = c(x = 1), times = seq(0, 10, by = 0.1), func = growth, parms = c(r = r))
  as.data.frame(out) %>% transform(r = r)
}))

# Plot the results
ggplot(results, aes(x = time, y = x, color = factor(r))) + 
  geom_line(linewidth = 1) + 
  facet_wrap(~r, scales = "free_y") + 
  labs(title = "Exponential Growth for Different Rates", 
       x = "Time", 
       y = "x(t)", 
       color = "r") + 
  theme_minimal()

```


```{r}
# Load necessary libraries
library(ggplot2)
library(grid)

# Parameters
k <- 2

# Grid of points
x_vals <- seq(-2, 2, length.out = 20)
y_vals <- seq(-2, 2, length.out = 20)
grid <- expand.grid(x = x_vals, y = y_vals)

# Calculate vector field
grid$dx <- grid$y
grid$dy <- -k * grid$x

# Normalize arrows
L <- sqrt(grid$dx^2 + grid$dy^2)
grid$dxn <- grid$dx / L * 0.15
grid$dyn <- grid$dy / L * 0.15

# Plot the direction field
ggplot(grid, aes(x = x, y = y)) +
  geom_segment(aes(xend = x + dxn, yend = y + dyn), 
               arrow = arrow(length = unit(0.15, "cm")), 
               linewidth = 0.4, color = "steelblue") +
  coord_fixed() +
  labs(title = "Direction Field for x' = y, y' = -k x", 
       x = "x", y = "y") +
  theme_minimal()


```


```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Linear ODE: x'(t) = a * x(t)
linear_model <- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    dx <- a * x
    list(c(dx))
  })
}

# Settings
state <- c(x = 1)
parameters <- c(a = 0.3)
times <- seq(0, 10, 0.1)

# Numerical integration
out <- ode(y = state, times = times, func = linear_model, parms = parameters)
out_df <- as.data.frame(out)

# Analytical solution: x(t) = x0 * exp(a * t)
out_df$analytic <- state["x"] * exp(parameters["a"] * out_df$time)

# Plotting
ggplot(out_df, aes(x = time)) +
  geom_line(aes(y = x, color = "Numerical solution"), linewidth = 1) +
  geom_line(aes(y = analytic, color = "Analytical solution"), linetype = "dashed", linewidth = 1) +
  scale_color_manual(values = c("Numerical solution" = "steelblue", "Analytical solution" = "red")) +
  labs(title = "Linear ODE: numerical vs analytical", y = "x(t)", color = "Legend") +
  theme_minimal()


```


```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Non-autonomous growth model: x'(t) = x(t) * (1 + sin(t))
nonauto <- function(t, state, parameters) {
  with(as.list(state), {
    dx <- x * (1 + sin(t))
    list(c(dx))
  })
}

# Initial state and times
state <- c(x = 1)
times <- seq(0, 30, by = 0.05)

# Solve the ODE numerically
out <- ode(y = state, times = times, func = nonauto, parms = NULL)

# Convert output to a data frame
out_df <- as.data.frame(out)

# Plot the solution
ggplot(out_df, aes(x = time, y = x)) +
  geom_line(color = "purple", linewidth = 1) +
  labs(title = "Non-autonomous growth: x'(t) = x(t) * (1 + sin(t))", 
       y = "x(t)", 
       x = "Time") +
  theme_minimal()

```



```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Lotka-Volterra system of equations (predator-prey model)
lv <- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    dx <- alpha * x - beta * x * y  # Rate of change for prey
    dy <- delta * x * y - gamma * y  # Rate of change for predator
    list(c(dx, dy))
  })
}

# Initial conditions and parameters
state <- c(x = 5, y = 2)  # Initial population of prey (x) and predator (y)
parameters <- c(alpha = 1.1, beta = 0.4, gamma = 0.4, delta = 0.1)

# Time sequence for simulation
times <- seq(0, 50, by = 0.1)

# Solve the system of equations
out <- ode(y = state, times = times, func = lv, parms = parameters)

# Convert the output to a data frame
out_df <- as.data.frame(out)

# Plot the results using ggplot2
ggplot(out_df, aes(x = time)) +
  geom_line(aes(y = x, color = "Prey"), linewidth = 1) +  # Prey population
  geom_line(aes(y = y, color = "Predator"), linewidth = 1) +  # Predator population
  labs(title = "Lotka-Volterra Dynamics", y = "Population", color = "Species") +
  scale_color_manual(values = c("Prey" = "darkgreen", "Predator" = "darkred")) +
  theme_minimal()

```


```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Lotka-Volterra system of equations (predator-prey model)
lv_rhs <- function(t, state, pars) {
  with(as.list(c(state, pars)), {
    dx <- alpha * x - beta * x * y  # Rate of change for prey
    dy <- delta * x * y - gamma * y  # Rate of change for predator
    list(c(dx, dy))
  })
}

# Parameters for the Lotka-Volterra model
parameters <- c(alpha = 1.1, beta = 0.4, gamma = 0.4, delta = 0.1)

# Create a grid of points in the (x, y) plane
grid <- expand.grid(x = seq(0, 10, length.out = 20),
                    y = seq(0, 10, length.out = 20))

# Calculate the vector field for each point in the grid
field <- within(grid, {
  dx <- parameters["alpha"] * x - parameters["beta"] * x * y
  dy <- parameters["delta"] * x * y - parameters["gamma"] * y
  len <- sqrt(dx^2 + dy^2)  # Length of each vector
  u <- dx / len  # Normalized x-component
  v <- dy / len  # Normalized y-component
})

# Initial condition for the trajectory
state0 <- c(x = 5, y = 2)

# Time sequence for simulation
times <- seq(0, 50, by = 0.1)

# Solve the ODE for the trajectory
traj <- as.data.frame(ode(y = state0, times = times, func = lv_rhs, parms = parameters))

# Plot the phase plane with the vector field and trajectory
ggplot() +
  # Plot the vector field
  geom_segment(data = field,
               aes(x = x, y = y, xend = x + 0.3 * u, yend = y + 0.3 * v),
               alpha = 0.6) +
  # Plot the trajectory
  geom_path(data = traj, aes(x = x, y = y), color = "blue", linewidth = 1) +
  coord_equal() +  # Equal scaling on both axes
  labs(title = "Lotka-Volterra Phase Plane",
       x = "Prey x(t)", y = "Predator y(t)") +
  theme_minimal()

```

```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Define the matrix A
A <- matrix(c(0, -1, 1, 0), nrow = 2, byrow = TRUE)

# Define the linear system of differential equations
linear2d <- function(t, state, parameters) {
  list(A %*% state)  # Matrix multiplication of A and the state vector
}

# Initial conditions and time sequence
state <- c(x = 1, y = 0)
times <- seq(0, 20, by = 0.05)

# Solve the ODE using deSolve's ode function
out <- ode(y = state, times = times, func = linear2d, parms = NULL)

# Convert the output to a data frame
out_df <- as.data.frame(out)

# Plot the phase trajectory using ggplot2
ggplot(out_df, aes(x = x, y = y)) +
  geom_path(color = "steelblue", linewidth = 1) +  # Plot the trajectory
  labs(title = "Phase Trajectory: Linear System x' = A x", x = "x(t)", y = "y(t)") +
  theme_minimal()

```

```{r}
# Eksport statycznej figury ggplot (np. do artykulu )
# Load necessary libraries
library(ggplot2)
library(htmlwidgets)
library(plotly)

# Example data for ggplot (replace with your own data if needed)
num <- data.frame(time = seq(0, 10, by = 0.1), x = sin(seq(0, 10, by = 0.1)))  # Example data

# Static plot with ggplot
p <- ggplot(num, aes(time, x)) +
  geom_line() +
  theme_minimal()

# Export static plot to PDF
ggsave("linear_solution.pdf", plot = p, width = 5.5, height = 3.5)

# Create an interactive plot using plotly (example)
plt <- ggplot(num, aes(time, x)) +
  geom_line() +
  theme_minimal()

# Convert ggplot to plotly for interactivity
interactive_plot <- ggplotly(plt)

# Export interactive plot to HTML
saveWidget(interactive_plot, "lv_phase_interactive.html", selfcontained = TRUE)

```



```{r}
# Load necessary libraries
library(deSolve)
library(ggplot2)

# Define the damped system of ODEs
damped <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    list(c(dx = y, dy = -alpha * y - beta * x))
  })
}

# Initial conditions grid
ICs <- expand.grid(x = seq(-1.5, 1.5, length = 7),
                   y = seq(-1.5, 1.5, length = 7))

# Time sequence
times <- seq(0, 10, by = 0.02)

# Parameters
parms <- c(alpha = 0.6, beta = 1.2)

# Function to simulate ODE for given initial conditions
sim_one <- function(x0, y0) {
  as.data.frame(ode(y = c(x = x0, y = y0), times = times, func = damped, parms = parms))
}

# Use Map to simulate the system for all initial conditions
bundle <- do.call(rbind, Map(function(x0, y0) {
  cbind(sim_one(x0, y0), x0 = x0, y0 = y0)
}, ICs$x, ICs$y))

# Plot the results
ggplot(bundle, aes(x = x, y = y, group = interaction(x0, y0))) +
  geom_path(alpha = 0.8) +
  geom_point(data = transform(ICs, time = 0), aes(x = x, y = y), size = 0.6, inherit.aes = FALSE) +
  coord_equal() +
  theme_minimal() +
  labs(title = "Trajectory bundle toward a stable focus", x = "x(t)", y = "y(t)")

```


```{r}
# Load necessary libraries
library(shiny)
library(deSolve)
library(ggplot2)

# Define logistic growth function
logistic <- function(t, state, parms) {
  with(as.list(c(state, parms)), {
    dx <- r * x * (1 - x / K)
    list(c(dx))
  })
}

# Define UI for the Shiny app
ui <- fluidPage(
  titlePanel("Logistic growth: interactive parameters"),
  
  sidebarLayout(
    sidebarPanel(
      sliderInput("r", "Growth rate r:",
                  min = 0.1, max = 2.0, value = 0.8, step = 0.1),
      sliderInput("K", "Carrying capacity K:",
                  min = 5, max = 50, value = 20, step = 1),
      sliderInput("x0", "Initial condition x(0):",
                  min = 0.1, max = 40, value = 1, step = 0.1)
    ),
    
    mainPanel(
      plotOutput("trajPlot", height = "400px")
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  
  output$trajPlot <- renderPlot({
    # Define parameters based on user input
    parms <- c(r = input$r, K = input$K)
    state <- c(x = input$x0)
    
    # Define time sequence
    times <- seq(0, 20, by = 0.1)
    
    # Solve the ODE
    out <- ode(y = state, times = times, func = logistic, parms = parms)
    
    # Convert output to a data frame
    out_df <- as.data.frame(out)
    
    # Plot the result
    ggplot(out_df, aes(time, x)) +
      geom_line(color = "darkgreen", linewidth = 1) +
      labs(title = "Logistic growth with interactive parameters",
           x = "Time", y = "x(t)") +
      theme_minimal()
  })
}

# Run the Shiny app
shinyApp(ui = ui, server = server)

```

